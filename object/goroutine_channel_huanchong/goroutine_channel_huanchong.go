package main

import (
	"fmt"
	"time"
)

func main() {
	//带缓冲的channel 3是容量,可以存储3个元素
	c := make(chan int, 3)
	fmt.Println("len(c)=", len(c), "cap(c)=", cap(c))

	go func() {
		defer fmt.Println("goroutine defer")
		//循环写入数据,如果超过容量,则会阻塞,等待外层取出数据,才会继续写入,外面取出一个,这里就可以继续写入
		//第一步:写入3个元素0,1,2,当写入第四个元素的时候,会阻塞,等待外层取出数据才可以继续写入
		for i := 0; i < 4; i++ {
			c <- i
			fmt.Println("写入数据", i, "len(c)=", len(c), "cap(c)=", cap(c))
		}
	}()

	//主线程休眠2秒
	time.Sleep(2 * time.Second)

	//第二步: 读取数据,当取出第一个元素0的时候,第一步的管道中就有2个元素了,管道解除阻塞,然后管道中继续写入数据
	//第三步: 读取数据一直读,直到管道中没有数据,这时候管道又会阻塞,等待第一步写入数据

	//上面写入最后一个元素,肯定在读取第一个元素之后,因为管道只能存3个值,这里只有取出一个管道才能继续写入,这个顺序是确定的

	//注意,写入数据与读取数据是异步的,不是同步的,所以这里的顺序是不确定的,但是读取数据一定在写入数据之后,因为取数据时管道没数据就会阻塞等待,
	//写数据时管道满了就会阻塞等待外面取出数据,管道容量调大,去掉休眠时间,就会发现读与写的顺序是不确定的
	for i := 0; i < 4; i++ {
		num := <-c
		fmt.Println("读取数据", num)
		time.Sleep(2 * time.Second)

	}

	fmt.Println("main end")
}
